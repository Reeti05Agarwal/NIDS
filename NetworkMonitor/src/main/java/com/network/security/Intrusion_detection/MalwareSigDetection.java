package com.network.security.Intrusion_detection;

public class MalwareSigDetection {

    private String checkTypeMS;
    private String patternMS;
    private String fieldMS;
    private String severity;

    public String getCheckTypeMS() {
        return checkTypeMS;
    }

    public void setCheckTypeMS(String checkTypeMS) {
        this.checkTypeMS = checkTypeMS;
    }

    public String getPatternMS() {
        return patternMS;
    }

    public void setPatternMS(String patternMS) {
        this.patternMS = patternMS;
    }

    public String getFieldMS() {
        return fieldMS;
    }

    public void setFieldMS(String fieldMS) {
        this.fieldMS = fieldMS;
    }

    public String getSeverity() {
        return severity;
    }

    public void setSeverity(String severity) {
        this.severity = severity;
    }

    /**
     * Detects if the payload contains the configured malware signature.
     */
    public boolean BAD_SIGNATURE_1(String payload) {
        if (payload != null && patternMS != null && payload.contains(patternMS)) {
            System.out.println("Malware Signature detected: " + payload);
            return true;
        }
        return false;
    }

    /**
     * Flags TCP packets whose checksum is non‑zero.
     */
    public boolean INVALID_TCP_CHECKSUM(int checksum) {
        if (checksum != 0) {
            System.out.println("Invalid TCP checksum detected: " + checksum);
            return true;
        }
        return false;
    }

    /**
     * Stub for checking non‑standard TCP flag combinations.
     *
     * @param flags the TCP flags field as a string
     */
    public boolean NON_STANDARD_TCP_FLAGS(String flags) {
        // TODO: implement actual flag‑pattern checks
        return false;
    }

    /**
     * True if the TCP header length is zero.
     *
     * @param headerLength length of the TCP header in bytes
     */
    public boolean ZERO_LENGTH_TCP_HEADER(int headerLength) {
        return headerLength == 0;
    }

    /**
     * True if port is outside the valid 1–65535 range.
     *
     * @param port the TCP/UDP port number
     */
    public boolean INVALID_PORT_RANGE(int port) {
        return port < 1 || port > 65_535;
    }

    /**
     * Stub for detecting reserved bits set in packet flags.
     *
     * @param flags numeric flag bits
     */
    public boolean RESERVED_BITS_SET(int flags) {
        // e.g., return (flags & 0b11100000) != 0;
        return false;
    }

    /**
     * True if payload is empty but flags are non‑zero.
     *
     * @param payload packet payload
     * @param flags packet flags as string
     */
    public boolean EMPTY_PAYLOAD_WITH_FLAGS(String payload, String flags) {
        boolean noPayload = (payload == null || payload.isEmpty());
        boolean hasFlags = (flags != null && !flags.equals("0"));
        return noPayload && hasFlags;
    }
}
